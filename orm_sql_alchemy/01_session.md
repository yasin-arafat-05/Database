
# `#01 Session:`

[documnetation_link](https://docs.sqlalchemy.org/en/20/orm/session_basics.html#using-a-sessionmaker)

### সেশন কী এবং এটি কী করে?
সেশন হলো SQLAlchemy-তে একটি মধ্যবর্তী স্তর, যা ডাটাবেসের সাথে সমস্ত যোগাযোগ পরিচালনা করে। এটি আপনার প্রোগ্রামে ORM-ম্যাপড অবজেক্টগুলো (যেমন, পাইথন ক্লাস যা ডাটাবেসের টেবিলের সাথে সংযুক্ত) পরিচালনা করে এবং ডাটাবেসের সাথে তাদের সমন্বয় রাখে। এটির মূল কাজগুলো হলো:

1. **ডাটাবেসের সাথে কথোপকথন (Conversations)**:
   - সেশন ডাটাবেসের সাথে সমস্ত ক্রিয়াকলাপ (যেমন SELECT, INSERT, UPDATE, DELETE) পরিচালনা করে।
   - এটি ডাটাবেস থেকে ডেটা লোড করে এবং ORM অবজেক্টগুলোকে আপনার প্রোগ্রামে উপলব্ধ করে।

2. **অবজেক্ট ম্যানেজমেন্ট (Identity Map)**:
   - সেশন একটি **আইডেন্টিটি ম্যাপ** নামে একটি ডেটা স্ট্রাকচার রাখে, যেখানে প্রতিটি অবজেক্টের একটি ইউনিক কপি থাকে। এখানে "ইউনিক" বলতে বোঝায় যে একটি নির্দিষ্ট প্রাইমারি কী (primary key) সহ শুধুমাত্র একটি অবজেক্ট থাকবে।
   - উদাহরণস্বরূপ, যদি আপনি একই মুভি (movie_id=1) দুইবার লোড করেন, সেশন নিশ্চিত করে যে এটি একই অবজেক্ট রিটার্ন করবে, যাতে ডেটার অসঙ্গতি না হয়।

3. **ট্রানজ্যাকশন ম্যানেজমেন্ট**:
   - সেশন ডাটাবেসের সাথে একটি ট্রানজ্যাকশন শুরু করে এবং এটি কমিট (commit) বা রোলব্যাক (rollback) না করা পর্যন্ত সেই ট্রানজ্যাকশনের মধ্যে কাজ করে।
   - ট্রানজ্যাকশন শেষ হলে, সেশন কানেকশনটি ডাটাবেস ইঞ্জিনের কানেকশন পুলে ফেরত দেয়।

4. **ইউনিট অফ ওয়ার্ক প্যাটার্ন (Unit of Work)**:
   - সেশন আপনার প্রোগ্রামে করা পরিবর্তনগুলো (যেমন, অবজেক্টের অ্যাট্রিবিউট পরিবর্তন) ট্র্যাক করে এবং ডাটাবেসে কোয়েরি চালানোর আগে বা ট্রানজ্যাকশন কমিট করার আগে এই পরিবর্তনগুলোকে ফ্লাশ (flush) করে। এটি নিশ্চিত করে যে ডাটাবেসের সাথে অবজেক্টগুলোর অবস্থা সিঙ্ক্রোনাইজড থাকে।

5. **প্রক্সি অবজেক্ট হিসেবে কাজ**:
   - সেশনের মাধ্যমে পরিচালিত ORM অবজেক্টগুলো ডাটাবেসের রো (row)-এর প্রক্সি হিসেবে কাজ করে। এরা সেশনের ট্রানজ্যাকশনের মধ্যে ডাটাবেসের সাথে সিঙ্ক্রোনাইজড থাকে।
   - যদি কোনো অবজেক্ট সেশন থেকে ডিটাচ (detach) করা হয়, তবে এটি ডাটাবেসের সাথে সিঙ্ক্রোনাইজড থাকবে না এবং পুনরায় ব্যবহারের জন্য নতুন সেশনের সাথে সংযুক্ত করতে হবে।

---

### সেশনের ব্যবহার
সেশন ব্যবহারের প্রাথমিক ধাপ এবং প্যাটার্নগুলো নিচে ব্যাখ্যা করা হলো:

#### 1. **সেশন তৈরি এবং বন্ধ করা (Opening and Closing a Session)**:
- সেশন সাধারণত একটি **ইঞ্জিন** (Engine) এর সাথে তৈরি করা হয়, যা ডাটাবেসের সাথে সংযোগ স্থাপনের জন্য ব্যবহৃত হয়।
- এটি সাধারণত একটি **কনটেক্সট ম্যানেজার** (with স্টেটমেন্ট) এর মাধ্যমে ব্যবহৃত হয়, যাতে কাজ শেষে সেশন স্বয়ংক্রিয়ভাবে বন্ধ হয়।

**উদাহরণ**:
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import Session

# ইঞ্জিন তৈরি
engine = create_engine("postgresql+psycopg2://scott:tiger@localhost/")

# সেশন তৈরি এবং অবজেক্ট যোগ করা
with Session(engine) as session:
    session.add(some_object)
    session.add(some_other_object)
    session.commit()
```
- এখানে, `Session(engine)` একটি নতুন সেশন তৈরি করে, যা ইঞ্জিনের মাধ্যমে ডাটাবেসের সাথে সংযুক্ত হয়।
- `with` স্টেটমেন্ট নিশ্চিত করে যে ব্লক শেষ হলে সেশন বন্ধ হবে (`Session.close()`)।
- `session.commit()` ডাটাবেসে পরিবর্তনগুলো সংরক্ষণ করে। এটি ঐচ্ছিক, কারণ যদি শুধু SELECT কোয়েরি চালানো হয় এবং কোনো পরিবর্তন না করা হয়, তবে কমিটের প্রয়োজন নেই।

**নোট**:
- `session.commit()` কল করার পর সেশনের সব অবজেক্ট **এক্সপায়ার** (expire) হয়, অর্থাৎ তাদের ডেটা পুনরায় লোড করতে হবে পরবর্তী ট্রানজ্যাকশনের জন্য। এটি এড়াতে `Session.expire_on_commit=False` সেট করা যায়।

#### 2. **ট্রানজ্যাকশন ফ্রেমিং (Begin/Commit/Rollback)**:
- সেশন একটি ট্রানজ্যাকশন শুরু করে এবং এটি কমিট বা রোলব্যাক না করা পর্যন্ত চলতে থাকে।
- যদি কোনো ত্রুটি (exception) হয়, তবে ট্রানজ্যাকশন রোলব্যাক করা হয়, যাতে ডাটাবেসে কোনো অসঙ্গতি না থাকে।

**লম্বা পদ্ধতি**:
```python
with Session(engine) as session:
    session.begin()
    try:
        session.add(some_object)
        session.add(some_other_object)
    except:
        session.rollback()  # ত্রুটি হলে রোলব্যাক
        raise
    else:
        session.commit()  # সফল হলে কমিট
```
- এখানে `try/except/else` ব্লক ব্যবহার করা হয়েছে ট্রানজ্যাকশন ম্যানেজ করার জন্য।

**সংক্ষিপ্ত পদ্ধতি**:
```python
with Session(engine) as session, session.begin():
    session.add(some_object)
    session.add(some_other_object)
```
- `session.begin()` একটি কনটেক্সট ম্যানেজার রিটার্ন করে, যা সফল হলে কমিট করে এবং ত্রুটি হলে রোলব্যাক করে। ব্লক শেষে সেশন বন্ধ হয়।

#### 3. **সেশনমেকার (sessionmaker) ব্যবহার**:
- `sessionmaker` হলো একটি ফ্যাক্টরি ক্লাস, যা একটি নির্দিষ্ট কনফিগারেশন সহ সেশন তৈরি করে।
- এটি সাধারণত মডিউল-লেভেলে তৈরি করা হয়, যাতে একই ইঞ্জিন ব্যবহার করে একাধিক সেশন তৈরি করা যায়।

**উদাহরণ**:
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# ইঞ্জিন তৈরি
engine = create_engine("postgresql+psycopg2://scott:tiger@localhost/")

# সেশনমেকার তৈরি
Session = sessionmaker(engine)

# সেশন ব্যবহার
with Session() as session:
    session.add(some_object)
    session.commit()
```
- এখানে `Session()` প্রতিবার নতুন সেশন তৈরি করে, কিন্তু ইঞ্জিন পাস করার প্রয়োজন নেই।
- `Session.begin()` ব্যবহার করে ট্রানজ্যাকশন এবং ক্লোজিং একসাথে করা যায়:
```python
with Session.begin() as session:
    session.add(some_object)
    session.add(some_other_object)
```

---

### গুরুত্বপূর্ণ ধারণা
1. **ইউনিট অফ ওয়ার্ক প্যাটার্ন**:
   - সেশন আপনার প্রোগ্রামে করা সব পরিবর্তন ট্র্যাক করে। যখনই আপনি কোনো অবজেক্টের অ্যাট্রিবিউট পরিবর্তন করেন, সেশন এটি রেকর্ড করে।
   - যখন ডাটাবেসে কোয়েরি চালানো হয় বা ট্রানজ্যাকশন কমিট করা হয়, তখন সেশন সব পেন্ডিং পরিবর্তন ফ্লাশ করে ডাটাবেসে।

2. **অবজেক্ট ডিটাচমেন্ট**:
   - সেশন থেকে কোনো অবজেক্ট ডিটাচ করা যায়, কিন্তু তখন এটি ডাটাবেসের সাথে সিঙ্ক্রোনাইজড থাকবে না।
   - ডিটাচড অবজেক্ট পুনরায় ব্যবহারের জন্য নতুন সেশনের সাথে সংযুক্ত করতে হবে।

3. **এক্সপায়ার অন কমিট**:
   - ডিফল্টভাবে, `session.commit()` কল করার পর সব অবজেক্ট এক্সপায়ার হয়। এর মানে, পরবর্তী ট্রানজ্যাকশনে তাদের ডেটা পুনরায় লোড করতে হবে।
   - যদি এটি এড়াতে চান, তবে `Session(expire_on_commit=False)` ব্যবহার করা যায়।

4. **কানেকশন পুল**:
   - সেশন ইঞ্জিনের কানেকশন পুল থেকে কানেকশন নেয় এবং ট্রানজ্যাকশন শেষে তা ফেরত দেয়। এটি স্কেলেবল এবং দক্ষ।

---

### কখন এবং কীভাবে সেশন ব্যবহার করবেন?
- **মডিউল-লেভেল ইঞ্জিন এবং সেশনমেকার**: অ্যাপ্লিকেশনের শুরুতে একটি ইঞ্জিন এবং সেশনমেকার তৈরি করুন। এগুলো একাধিক ফাংশন বা থ্রেডে ব্যবহার করা যায়।
- **কনটেক্সট ম্যানেজার**: সবসময় `with` স্টেটমেন্ট ব্যবহার করুন, যাতে সেশন সঠিকভাবে বন্ধ হয় এবং কানেকশন লিক না হয়।
- **ট্রানজ্যাকশন ম্যানেজমেন্ট**: সবসময় ট্রানজ্যাকশন কমিট বা রোলব্যাক করুন। ত্রুটি হলে রোলব্যাক নিশ্চিত করতে `session.begin()` ব্যবহার করুন।
- **অবজেক্ট ট্র্যাকিং**: সেশনের মাধ্যমে অবজেক্ট পরিবর্তন করলে, সেশন স্বয়ংক্রিয়ভাবে ডাটাবেসে সিঙ্ক্রোনাইজ করবে।

---

### উদাহরণ: বাস্তব অ্যাপ্লিকেশনে সেশন
ধরুন, আপনার একটি মুভি ডাটাবেস আছে, এবং আপনি একটি নতুন মুভি যোগ করতে চান:
```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import declarative_base, sessionmaker

Base = declarative_base()

# মুভি ক্লাস
class Movie(Base):
    __tablename__ = 'movies'
    id = Column(Integer, primary_key=True)
    title = Column(String)

# ইঞ্জিন এবং সেশনমেকার
engine = create_engine("postgresql+psycopg2://scott:tiger@localhost/")
Session = sessionmaker(engine)

# ডাটাবেসে টেবিল তৈরি
Base.metadata.create_all(engine)

# নতুন মুভি যোগ
with Session.begin() as session:
    new_movie = Movie(title="Inception")
    session.add(new_movie)
# কমিট স্বয়ংক্রিয়ভাবে হয়, সেশন বন্ধ হয়
```
- এখানে `Session.begin()` ট্রানজ্যাকশন শুরু করে, নতুন মুভি যোগ করে, এবং সফল হলে কমিট করে।

---

### সেশনের সুবিধা এবং সতর্কতা
**সুবিধা**:
- ডাটাবেস অপারেশন সহজ করে এবং ORM অবজেক্টগুলোকে ডাটাবেসের সাথে সিঙ্ক্রোনাইজড রাখে।
- ট্রানজ্যাকশন ম্যানেজমেন্ট স্বয়ংক্রিয়ভাবে পরিচালনা করে।
- কানেকশন পুল ব্যবহার করে দক্ষতা বাড়ায়।

**সতর্কতা**:
- সেশন বন্ধ না করলে কানেকশন লিক হতে পারে। সবসময় `with` স্টেটমেন্ট ব্যবহার করুন।
- বড় ডাটাসেটের ক্ষেত্রে সেশনের মেমরি ব্যবহার বাড়তে পারে, তাই অবজেক্টগুলো সঠিকভাবে ম্যানেজ করুন।
- ডিটাচড অবজেক্ট ব্যবহারের সময় সতর্ক থাকুন, কারণ এগুলো ডাটাবেসের সাথে সিঙ্ক্রোনাইজড থাকবে না।

---

### সেশনের তুলনা
সেশনকে একটি "শপিং কার্ট" হিসেবে ভাবা যায়। আপনি কার্টে আইটেম (অবজেক্ট) যোগ করেন, পরিবর্তন করেন, এবং চেকআউট (commit) করার সময় সবকিছু ডাটাবেসে সংরক্ষিত হয়। যদি কোনো সমস্যা হয়, তবে কার্ট খালি করা হয় (rollback)।




